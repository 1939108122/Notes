## HTTPS
HTTPS的引入就是为了数据在网络通信的过程中保证安全，而不被第三方劫持到信息，从而泄露。

http中存在的问题：
1. 数据传输采用明文传输，容易被窃取。
2. 没有验证身份，容易被冒充。

HTTPS：引入SSL/TLS 证书来验证服务器的身份，并为之加密。

HTTPS的缺点： 
1. 在进入传输层之前，要进行SSL握手，导致页面加载时间过长。
2. SSL证书申请需要花费资金。
3. SSL握手算法导致服务器消耗比较大。

1. 明文传输：客户端与服务器之间数据完全没有加密，一旦被第三者劫持，会被盗取信息。
2. 对称加密： 对称加密指的是客户端和服务器之间共依赖一个密钥，由客户端使用这个密钥对数据加密，服务端使用这个密钥对数据解密。
    但是当客户端将密钥传送给服务端时，第三者会劫持得到这个密钥，在之后的传输数据过程，则会利用这个密钥来进行解密盗取信息，显然是不安全的。

3. 非对称加密： 由服务器生成密钥对，公钥发给客户端进行加密，私钥留在服务器，等待客户端加密过后的密钥发来进行解密。
## 公钥和私钥是多对一的关系，公钥加密过后的信息，只有私钥能解开， 私钥加密过后的信息，所有和他有关系的公钥都能解开。
  具体过程：
  1. 客户端：发送一个HTTP请求，要求服务器给我一个公钥。
  2. 服务器生成密钥对，将公钥发送给客户端，私钥留给自己。
  3. 客户端收到公钥，生成一个随机数，作为对称加密的密钥，然后用公钥对随机数进行加密，发送给服务器。
  4. 服务器用一开始生成的私钥对客户端发送过来的公钥进行解密，从而得到密钥，可以进行后续的通信。

**问题所在： 当服务器发送公钥给客户端的时候，第三者很有可能将公钥拦截，自己生成密钥对，然后把自己的公钥发给客户端，客户端
对随机数加密后，第三者又用自己的私钥进行解密，得到密钥后发送给服务器，第三者就有了密钥，便会在后续客户端和服务器进行通信的时候盗取数据。

解决办法：只需要验证公钥是服务器发送过来的还是第三者就可以了，这里利用服务器向权威机构申请数字证书，证书包含了公钥。
具体过程： 
1. 服务器向权威机构申请一个数字证书，权威机构将带有公钥（权威机构的私钥加密过）的证书给服务器，服务器将它部署在机器上。
2. 客户端：发送一个HTTP请求，要求服务器给我一个公钥。
3. 服务器将含有公钥的证书发给客户端。
4. 客户端收到证书后，用内置的公钥解开经过权威机构私钥加密过的公钥，得到公钥。
5. 客户端生成随机数当成后续对称加密的密钥，再用得到的公钥对其加密，发送给服务器。
6. 服务器得到公钥，用之前的私钥解密，得到随机数，然后就可以根据这个随机数当做密钥进行与客户端的通信了。

## 权威机构的给服务器中的数字证书里面的公钥怎么加密的？
   经过权威公司的私钥进行加密的。

## 客户端的内置公钥哪里来的？
    许多权威机构都会与各大浏览器合作，会将他们的公钥内置在浏览器环境中。

## 当第三者也向权威机构申请证书，替换服务器发过来的证书，再发给客户端，这时候怎么解决？
虽然这时客户端用浏览器内置的公钥解开第三者的数字证书得到公钥，证书签名也没问题，但是客户端会检查当前访问的域名是否和
证书中的域名一致，不一致就会被认为是第三者了，停止发送。


## 对称加密和非对称加密
  1. 对称加密速度快，加密时CPU资源消耗少
  2. 非对称加密对数据有长度限制。



URI和URL
URI： 统一资源标记符， 通过URI可以知道一个资源是什么。例如身份证号
URL： 定位具体资源，通过URL可以知道资源具体的位置。地址

URL是URI的子集，URL只不过是通过描述位置来定位资源。

HTTP报文组成
请求报文：
 1. 请求行： 请求方法，请求URL，协议,版本。
 2. 请求头： 都是由键值对组成，比如： content-type：text/html, Host： 请求主机名。
 3. 空行： 请求头之后是一个空行，通知服务器以下不再有请求头
 4. 请求体： GET没有请求体，POST有，通常是一些数据。

响应报文:
1. 状态行： 协议和服务器返回给客户端的状态码 eg:HTTP/1.1 200 OK。
2. 响应头： content-type...
3. 空行（同上）
4. 响应体： 返回给客户端的数据
#### 知识要点
> 1. 作用域：作用域是一套**规则**，用于**确定在何处以及如何查找变量**（标识符）。
> 
解读：每一种编程语言，他最基本的能力就是能够存储变量中的值，并且允许我们访问和修改这个变量的值，那么有了变量之后，应该把它放在哪里，程序如何找到它们呢，这是不是我们要提前约定好一套存储变量，访问变量的规则？这套规则，就是我们常说的作用域。

> 2. 编译原理： 程序中的一段源代码会在执行之前会进行三个步骤：**分词/词法分析、解析/语法分析、代码生成**， 这三个步骤统称为： **编译**。


分词/语法分析：这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元，例如：var a = 2; 这段程序会被分解成 var， a, =, 2, ;。 （空格的解析取决于它是否在这门语言中有意义）

解析/语法分析： 这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个数被称为“**抽象语法树(AST)**”。

代码生成： 将AST转换为可执行代码的过程称为代码生成。简单来说就是有某种方法可以将 var a = 2; 的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存)，并将一个值储存在a中。


> 3. LHS（对其赋值）和RHS查询（取到它的源值）。在引擎执行代码时，会对变量进行查找是否声明过，这时引擎会LHS 和RHS查询。
>如果查找的目的是对目标进行赋值，那么就会使用 LHS查询， 如果目的是获取变量的值，就会使用RHS查询。


```js
console.log(a)  //RHS查询

a = 2 //LHS查询

```

```js
fuction foo(a) {
  console.log(a) //2
}
foo(2)

//三次RHS 查询 一次LHS查询

// foo(...)、console、a 为RHS查询
//  a = 2 LHS查询 
```
```js
function foo (a) {
  var b = a; 
  return a + b
}
var c = foo(2) 
// 三处LHS查询(c = ..., a = 2, b = ...)
// RHS查询 (foo(2..)、 = a、 a、b)
```
> 4. 区分LHS和RHS查询 
> 在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行为不一样的。

如果RHS查询在任何嵌套的作用域都无法找到所需的变量，引擎就会抛出Reference Error异常（重要异常类型）。
当执行LHS查询时，**在非严格模式下的话**，在全局作用域下没找到的话，就会自动在全局作用域创建该名称的变量，严格模式下就会会抛出Reference Error异常。




